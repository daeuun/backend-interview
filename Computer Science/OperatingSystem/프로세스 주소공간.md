💡 프로세스는 CPU에 의해서 실행이 되고 memory에 저장이 된다

1. 프로그램(Program)이 실행되면
2. **프로세스 주소 공간**(Process Address Space)이 **Memory에 할당**(생성)
3. **CPU**가 할당 된 프로세스를 실행

<br>


## 💡 Process Address Space

### 1. Code (Text)

- 작성한 소스코드가 들어 가는 부분

    즉, **실행할 프로그램의 코드**가 저장되는 영역

- 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 **함수, 제어문, 상수** 등이 지정된다.
- 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 **Read-Only**

### 2. Data

- 프로그램의 **전역 변수와 정적(static) 변수**가 저장되는 영역

    즉, 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역이다.

- 전역변수, static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 바뀐다.
- 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- 실행 중간에 전역변수가 변경 될 수도 있으니 **Read-Write**

### 3. Stack

- 함수의 호출과 관계되는 **지역 변수와 매개변수**가 저장되는 영역
- Stack은 함수의 호출과 함께 할당되며, **함수의 호출이 완료되면 소멸**한다.
- 원시타입의 데이터가 값과 함께 할당된다.
- Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다.
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- **컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없다.** 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 **stack overflow 에러**가 발생한다.

### **4. Heap**

- **런타임에 크기가 결정되는 메모리 영역**
- 사용자에 의해 메모리 **공간이 동적으로 할당되고 해제**된다.
- 참조형의 데이터의 값이 저장된다.
- 예를 들어 클래스, 클로저가 이 부분에 해당 된다.
- Heap은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- HEAP과 STACK영역은 사실 같은 공간을 공유한다. HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 HEAP OVERFLOW, STACK OVERFLOW라고 칭함.

<br>

**Q1. 왜 Code 부분을 따로 두었나? (Why OS separates code segment?)**

Program의 Code는 Program이 만들어지고(컴파일되고) 나서는 바뀔 일이 없어서 읽기만 가능한 Read Only 부분입니다. 

그렇기 때문에 같은 프로그램을 실행시켜 몇 개의 Prcess가 실행되더라도 같은 프로그램이라면 Code 부분은 다 똑같은 내용을 가지고 있게 됩니다. 

따라서 같은 프로그램의 프로세스일 경우 Code 부분을 공유(Share)하여 메모리 사용량을 줄이는 목적입니다.

**Q2. 왜 Stack 부분과 Data 부분을 나누었나? (Why Os separates stack from data segment?)**

Stack 구조는 하단 부가 막혀있고 상단 부가 뚫려있는 구조다. 

따라서 한 쪽으로만 데이터를 집어 넣을 수 있고, 꺼낼 때는 최근에 집어넣었던 것 부터 꺼낼 수 밖에 없는 구조다. 

함수의 Stack 구조로 인해 Data 부분과 Stack 부분을 따로 나눈 것이다. 

전역 변수(global variables)는 어떤 함수에서도 접근 할 수 있기 때문에 Data로 따로 관리한다. 

함수 외부(Outside function)와 함수(Inside function, 지역 변수 포함)에 따라서 Stack구조 활용을 위해 나눔.


**Q3. Data영역과 Bss 영역을 구분하는 이유는 무엇인가?**

초기화되지 않은 변수는 프로그램이 실행될 때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요는 없으나 초기화가 되는 변수는 그 값도 프로그램에 저장하고 있어야 하기 때문이다. 

따라서 bss 영역 변수들이 많아져도 프로그램의 실행코드 사이즈를 늘리지 않는다.
